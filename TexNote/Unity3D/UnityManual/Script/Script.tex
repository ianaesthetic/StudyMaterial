\documentclass[10pt, a4paper]{article}
    \author{ianaesthetic}
    \title{Unity3D note}
\usepackage{indentfirst, amsmath, fontspec, listings, xcolor}


\newfontfamily\consolas{Consolas}
\lstset{numberstyle = \footnotesize\consolas, basicstyle=\footnotesize\consolas}

\XeTeXlinebreaklocale "zh"
\XeTeXlinebreakskip = 0pt plus 1pt

\begin{document}
    \section{Scripting Overview}
        The whole note is devoted to introduce some special techniques towards engine. 
        \subsection{Creating and Using Script}
            The GameObject is controlled by the \emph{Component}, and script is used to modify and customize. 
            \subsubsection{How to create script}
            \subsubsection{Anatomy of Script File}
                Start(): It's called by Unity before gameplay begins.
                
                Update(): Handling the frame update for the GameObject
                
                The constructor is not needed as it's handled by the editor and may not take place at the start of gameplay. 

            \subsubsection{Controlling a GameObject}
                Script instance must be attached to a GameObject to control. 

                Debug.Log("message") can output to the console in the engine. 
            
        \subsection{Variables and the Inspector}
            Variables are declared public to be access in the Inspector. You can also make changes to the variables during the gameplay temporarily. 
        \subsection{Controlling GameObject Using Component}
            \subsubsection{Accessing Components}
                \emph{GetComponent()} function can be used to get reference to the component properties. 
\begin{lstlisting}
RigidBody rb = GetComponent<RigidBody>(); 
\end{lstlisting}
                you can use it to access the parameter and manipulate the instances.
            \subsubsection{Accessing other object} 
                You can either link objects with other variables with public gameObject, which is similar to the public variables. You can also declare a component and drag a other gameObject on it to attach component of other gameObject. This operation must be done in the editor rather than runtime. 

                \textbf{Finding Child Objects} and \textbf{Finding Objects by Name or Tag} can be used to locate gameObject in the runtime. 
                
                Finding Child Objects: when you want to keep track same kind of objects such as location of waypoints, you may make the child of a logical parent and can access them using foreach. 
\begin{lstlisting}
public gameObject wayPoints;
...
void Update() {
    int num = wayPoints.childCount;
    ... 
    foreach(Transform t in wayPoints){
        wayPointArray[i ++] = t; 
    }
    ...
    particularChild = wayPoints.Find("start"); 
}
\end{lstlisting} 

                Finding Objects by Name or Tag:
\begin{lstlisting}
\\GameObject[] gameObject_3;
gameObject_1 = GameObject.Find("Car"); 
gameObject_2 = GameObject.FindWithTag("Player");
gameObject_3 = GameObject.FindGameObjectsWithTag("Enemy");
\end{lstlisting}

        \subsection{Event Functions} 
            \textbf{Event Functions} are activated by Unity in response to events that occur during game play, such as Update() and Start().
            \subsubsection{Regular Update Events}
                \textbf{Update()} is the main function to make changes, taking place before each frames is rendered and each animations is calculated.
                
                \textbf{FixedUpdate()} is called before each physics update. This function is dedicated to the change of physics. 

                \textbf{LateUpdate()} can be able to make additional changes after Update() and FixedUpdate(). It can be used to adjust camera and character orientation. 
            \subsubsection{GUI events} 
                Unity has a system for rendering GUI controls over the main action in the scene and responding to clicks on these control. These code should be included in \emph{OnGUI()} function. 
\begin{lstlisting}
void OnGUI() {
    GUI.Label(labelRect, "Game Over"); //making a text or texture on screen
    /*
    Prototype: GUI.Label(Rect Position, string text);
               GUI.Label(Rect Position, Texture image);
    Rect: A 2D rectangle defined by left upper X and Y position, wight, height. 
          It can also be constructed by xMin, xMax, yMin, yMax. 
    */
}
\end{lstlisting}

                You can also detect \emph{mouse events} that occur over a GameObject as it appears in the scene, such as targeting weapons. \emph{OnMouseDown()} is called when user has pressed the mouse button while over the GUIElement or Collider. A call to \emph{OnMouseOver()} occurs on the first frame the mouse is over the object until the mouse moves away, at which point \emph{OnMouseExit()} is called. It needs the collider to be marked as trigger. More specific mouse and keyboard operations can go to look up for Monobehaviour.
            \subsubsection{Physics events}
                A series of function will be called when collision is detected, such as \emph{OnCollisionEnter()}. When collider is marked as trigger, it turns into \emph{OnTriggerEnter()}. Object may contact with multiple objects, which requires for a parameter to identify. 
        
        \subsection{Time and Framerate Management}
            The Update() allows monitoring inputs and other events from the script. A important thing is that neither framerate or length of time between Update() is called is constant. \emph{Time.deltaTime} is the time in seconds it took to complete the last frame. It remains constant when called from FixedUpdate(). In order to subtract or add for a constant per frame, multiply it by Time.deltaTime can guarantee a constant offset per frame. For example: 
\begin{lstlisting}
void Update() {
    Transform.position = (0.0f, 0.0f, distancePerSeconds * Time.deltaTime); 
}
\end{lstlisting}
            \subsubsection{Fixed Timestep}
                There is a fixed timestep between FixedUpdate() for physics engine. You can change it in \emph{Time Manager} and read from \emph{Time.fixedDeltaTime} in order to get better physical performance.  
            \subsubsection{Maximum Allowed Timestep}
                If fixed timestep is too small that gameplay framerate is relatively low, many physical update will in one framerate update, causing even lower fresh rate and unsynchronized movement. With the set of \emph{maximum allowed timestep} in \emph{time manager}, when the rendering time of one frame exceeds it, the physical engine will stop calculating and staying at that conditions waiting for the update of frame. It's a trade off that causes the movement slower than the real world while having better framerate.  
            \subsubsection{Time Scale}
                \textbf{timeScale} can be used to slow down or freeze the speed of game for bullet-time or pause. The value of it means the rate of speed. It will affect all the time and delta time measuring variables of the Time class except for \emph{realTimeSinceStartUp}. 
\begin{lstlisting}
void Pause() {
    Time.timeScale = 0; 
}
void Resume() {
    Time.timeScale = 1; 
}
\end{lstlisting}

            \subsubsection{Capture Framerate}
                \textbf{Capture Framerate} property is devoted to record the image or video of your gameplay duration. When captureFramerate is other than 0, the frame update rate will be set to have an interval of $\frac{1}{CFR}$ to have time to save images. It can be set to 25fps for video. 
\begin{lstlisting}
string folder = "ScreenshotFolder"; 
public int frameRate; 
void Start() {
    Time.captureFramerate = 1; 
    System.IO.Directory.CreateDirectory(folder); 
}

void Update() {
    string name = string.Format("{0}/{1:D04} shot.png", folder, Time.frameCount); 
    Application.CaptureScreenshot(name); 
}
\end{lstlisting}

        \subsection{Creating and Destroying GameObject.}
            GameObject can be created by \emph{Instantiate()} to make new copy of a gameObject, usually from prefab. \emph{Destroy()} is used to destroy a object with an allowed lifetime. Destroy() be used to destroy component . 
\begin{lstlisting}
Destroy(this); //This is used to destroy the script itself
\end{lstlisting}
        \subsection{Coroutine}
            \textbf{Coroutine} is function that has the ability to pause execution and return control to Unity but then continue where it left off on the following frame. It's essential a function to be declared with a return type of \emph{IEnumerator} and function will pause at the point of \emph{yield return line}. It will resume on the frame after it's yield by default but you can set a delay time with \emph{WaitForSeconds()}. The coroutine function can be used to spread an effect over a period of time and also can perform regular check and update which has a bigger interval than Update() interval. Coroutine functions will finally stop when all \emph{yield instructions} finishes.
\begin{lstlisting}
void Start() {
    StartCoroutine(Spawn); 
}

IEnumerator Spawn() {
    ...
    yield return WaitForSeconds(waitPlayer); 
    ...
}
\end{lstlisting}

            Coroutine are not stopped if the Monobehaviour is disabled. Coroutine can be stopped by either \emph{Monobehaviour.StopCoroutines} or \emph{Monobehaviour.StopAll-\newline \noindent -Coroutine}. It's also stopped when Monobehaviour is destroyed.
        \subsection{Namespaces}
            Just like c++, the class in a namespace can be accessed by adding a prefix. It allows same class name within different namespaces. You can avoid typing the prefix by \emph{using} directive at the top of the script. 
        \subsection{Attributes}
            \textbf{Attributes} are makers that can be placed over a class, property, or a function in a script to indicate special behavior like [HideInspector], [System.Serialization];
        \subsection{Execution order of Events Functions}
            \subsubsection{Editor}
                \textbf{Reset()}: Reset is called to initialize the script's property when it's first attached to the object all Reset() is called. 
            \subsubsection{First Scene Loaded}
                \textbf{Awake()}: It's called always before Start() functions and also just after a prefab is instantiated and set active.

                \textbf{OnEnable()}(active required): This function is called just after the object is enabled when level is loaded or instanciated. 

                They can't be enforced when an object is instantiated during gameplay. 
            \subsubsection{Before the First Frame Update}
                \textbf{Start()}: Start is called before the first frame update on if the script instance is enabled. 
                
            \subsubsection{In Between Frames}
                \textbf{OnApplicationPause(bool)}: This is called at the end of frame where the pause is detected, effectively between the normal frame updates. One extra frame will be issued indicating obvious pause state. It is used in mobile game. 
            \subsubsection{Update Order}
                \textbf{FixedUpdate()}: It's often called more frequently than Update(), all physical updates will be done right after FixedUpdate(). There is no need for Time.timeDelta because FixedUpdate() has a constant fresh rate. 

                \textbf{Update()}: It's called once per frame. 

                \textbf{LateUpdate()}ï¼šIt's called after Update() is done. The most common use of it is third-person camera.

            \subsubsection{Rendering}
                \textbf{OnPreCull()}:Called before the camera culls the scene. Culling determines which an object becomes visible/invisible to the camera. 
                
                \textbf{OnBecomeVisible()/ OnBecomeInvisible()}: Called when an object becomes visible/invisible to any camera. 

                \textbf{OnWillRenderObject()}: Called once for each camera if the object is visible. 

                \textbf{OnPreRender()}: Called before the cameras starts to render the scene. 
                
                \textbf{OnRenderObject()}:Called after all regular scene rendering is done with GL class or Graphics.DrawMeshNow. 
                
                \textbf{OnPostObject()}:Called after a camera finishes rendering the scene. 

                \textbf{OnRenderImage()}:Called after scene is complete to allow for post-processing of the image. \emph{Post Processing} is the process of applying full-screen filters and effects to the camera's image buffer.
                
                \textbf{OnGUI()}:Called multiple times per frame in the response to \emph{GUI events}, the \emph{layout} and \emph{repaint} is the first, followed by a layout and keyboard/mouse event for each input event. 
                
                \textbf{OnDrawGizmos}:Used for drawing Gizmos in the scene view for visualization.
            \subsubsection{Coroutine}
                Normal Coroutines updates are run after the Update function returns. There are different types of yield instructions: 
                
                \textbf{yield}:The coroutine will continue after all Update functions have been called on the next frame.

                \textbf{yield return WaitForSeconds()}:Continue after a specific delay after all Update() have been called on the next frame. 

                \textbf{yield return WaitForFixedUpdate()}: Continue after all FixedUpdate has been called on the next frame. 

                \textbf{yield return WWW}:Continue after a WWW download complete. 
                
                \textbf{yield StartCoroutine()}: chains the routine, and will wait for the MyFun coroutine to complete first. 
            \subsubsection{When the Object is destroyed}
                \textbf{OnDestroy()}:The function is called after all frame updates for the last frame of the object's existence. 
            \subsubsection{When Quitting}
                These functions get called on all the active objects in the scene:
                
                \textbf{OnApplicationQuit()}: This is called before all the application is quit and when user stops play mode. 

                \textbf{OnDisable()}: This function is called when the behavior becomes disable or inactive. 
            \subsubsection{Script LifeCycle Flowchart}
                Please refer to https://docs.unity3d.com/Manual/ExecutionOrder.htm. 
        \subsection{Understanding Automatic Memory}
            The memory required to store it is allocated from a central pool called \emph{heap}. When it is no longer used, they will be reclaimed and used for something else. Nowadays automatic management has decreases the coding effort and reduce the opportunity of memory leakage. 
            
            \subsubsection{Value and Reference}
                The pass of the parameter can be done by creating a instance in a memory block or a pointer to the location of the value. Type that directly stored with parameter is called \emph{value type}. Type that are allocated on the heap and then accessed via a pointer are called reference types.
            \subsubsection{Allocation and Garbage Collection}
                The memory manager will track all the unused memory and allocate it to incoming request. A reference item on the heap can only be accessed as long as there are still reference to it. If all references to a memory block has gone, it will be reallocated.

                \textbf{Garbage Collection}(GC) is the process that search through all active references and locate unused memory. 
            \subsubsection{Optimization}
                Improper coding will make automatic GC a disaster. For example : 
\begin{lstlisting}
void Example() {
    string line = inArray[0].Tostring(); 
    for(int i = 0; i < inArray.Length(); ++ i) {
        line += "," + inArray[i].ToString();
    }
}
\end{lstlisting}           

                In the example above, a completely new string wil be allocated which may cause hundreds of bytes of memory blocks to be freed every loop. It's better to use \emph{System.Text.StringBuilder()}.

                Another example is that the Text object to be updated every Update(). In order to optimize, we will update the Text when its content is changed. 
            
\begin{lstlisting}
float[] RandomList() {
    var result = new float[[numElements]; 
    for(int i = 0; i < numElements; ++ i) {
        result[i] = Random.value; 
    }
    return result; 
}
\end{lstlisting} 

                In order to reduce the time of reallocate, it's recommended to use reference array rather than creating a new one as above. 
            
            \subsubsection{Requesting a Collection}
                It's best to avoid allocations as far as possible. As they can't be eliminated, there are two strategies: \emph{Small heap with fast and frequent GC}; \emph{Large heap with slow but infrequent GC}. 

                The first strategy is often best for games that have long periods of gameplay where a smooth framerate in the main concern. It may make more collections than necessary, but still have better performances. 

                The second strategy works for games with infrequent collections and collections can be handled during the pauses in gameplay. You should manually allocate some placeholder to enlarge the heap. 
\begin{lstlisting}
void Start() {
    var tmp = System.Object [1024]; 
    for(int i = 0; i < 1024; ++ i) 
        tmp[i] = new byte[1024]; 
    tmp = 0;// release reference to get free block
}
\end{lstlisting}
                
                The collection should be done manually in the game pause: 
\begin{lstlisting}
    System.GC.Collect(); 
\end{lstlisting}

            \subsubsection{Reusable Object pool}
                It's better to have less objects to avoid GC waste. It's a good idea to reuse game object to have less objects stored. 

        \subsection{Platform Dependent Compilation} 
        

\end{document}